.\" Automatically generated by Pandoc 2.8.1
.\"
.TH "" "" "" "" ""
.hy
.SH CMSC312
.PP
The operating system simulation that is built in the class will live in
the repository.
.SH Building
.PP
without docker
.IP
.nf
\f[C]
\[ti]$ make
\f[R]
.fi
.PP
with docker
.IP
.nf
\f[C]
\[ti]$ make docker-build
\f[R]
.fi
.SH Execution
.PP
without docker
.IP
.nf
\f[C]
\[ti]$ ./jose
\f[R]
.fi
.PP
with docker
.IP
.nf
\f[C]
\[ti]$ docker run -it jose:latest
\f[R]
.fi
.SH Usage
.PP
When executed, the OS Shell is shown.
.IP
.nf
\f[C]
OS Shell
-------------------
==> 
\f[R]
.fi
.PP
The available commands for the shell are: - load - Load in template file
and create processes from it - e.g.\ load ProgramFiles/temp1.txt 1000 -
load template 1 and create 1000 processes - exit || quit - Exits
simulator
.SH Testing
.PP
To execute all tests for the application:
.IP
.nf
\f[C]
\[ti]$ make test
\f[R]
.fi
.PP
and for an individual module, just:
.IP
.nf
\f[C]
\[ti]$ go test module
\f[R]
.fi
.SH Assignment
.SS Part one
.PP
The requirements for project part 1 (deadline October 6th) are as
follows:
.IP \[bu] 2
\[u2612] having at least 4 of your own program file templates
.IP \[bu] 2
\[u2612] having a procedure that reads these program files and generates
user-specified number of processes from them (hence randomization of
values from templates must be used)
.IP \[bu] 2
\[u2612] assigning a PCB to each process that stores basic metadata,
including process state
.IP \[bu] 2
\[u2612] having a single scheduler that optimizes the process running
cycle
.IP \[bu] 2
\[u2612] having a dispatcher that changes the status of each process in
real time
.PP
All of this must be within a single application, not multiple separate
modules.
.PP
   *   *   *   *   *
.SS Part two
.PP
The requirements for project part 2 (deadline November 10th) are as
follows:
.IP \[bu] 2
\[u2612] adding critical sections to your processes (can be implemented
e.g., as enclosing selected instruction within critical section tag)
.IP \[bu] 2
\[u2612] implementing one selected critical section resolving algorithm
(mutex lock / semaphore / monitor)
.IP \[bu] 2
\[u2612] adding memory and basic operations on it + taking memory into
account when admitting processes into ready state and scheduler
.PP
Please remember that these requirements are minimal requirements for C/D
grade.
Those of you who aim for A/B grades must be aware that these require
much more functionalities to be implemented.
You are free to submit additional functionalities within project part 2
for evaluation.
.PP
   *   *   *   *   *
.SS Part three
.IP \[bu] 2
\[u2612] Multithreading
.IP \[bu] 2
[_] GUI (or TUI)
.PP
   *   *   *   *   *
.SS TODO
.IP \[bu] 2
Comment everything
.IP \[bu] 2
Critical section for multithreading
.IP \[bu] 2
Memory caching
.IP \[bu] 2
Parent + child
.RS 2
.IP \[bu] 2
pipes
.RE
.IP \[bu] 2
Two CPUs and Schedulers
.IP \[bu] 2
return when IO from process.execute to kernel
.IP \[bu] 2
Config for switching schedulers
.RS 2
.IP \[bu] 2
\[ga]- sched=\[lq]rr\[rq] || sched=\[lq]fcfs\[rq]\[ga]
.RE
.IP \[bu] 2
Init methods
.RS 2
.IP \[bu] 2
CPU
.IP \[bu] 2
Memory
.IP \[bu] 2
Scheduler
.RE
